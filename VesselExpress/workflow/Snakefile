import os
import platform
import snakemake


def get_files_and_extensions(path):
    files = [os.path.splitext(f) for f in os.listdir(path) if (f.endswith('tif') or f.endswith('.tiff')
             or f.endswith('.jpg')) or f.endswith('.png') and not f.startswith('.')
             and os.path.isfile(os.path.join(path,f))]
    file_names = [f[0] for f in files]
    file_extensions = [f[1].split('.')[1] for f in files]

    new_file_extensions = []
    for file_name, file_ext in zip(file_names, file_extensions):
        if file_ext == 'tif':
            os.rename(os.path.join(path, file_name + '.tif'), os.path.join(os.path.join(path, file_name + '.tiff')))
            file_ext = 'tiff'
        new_file_extensions.append(file_ext)

    return file_names, new_file_extensions


def get_graphAnalysis_command(os, script_path):
    command_str = \
        "python " + script_path + "/graphAnalysis.py -skel_img \"{input.skelImg}\" -bin_img \"{input.binImg}\" \
        -output_dir \"{output}\" -pixel_dimensions {config[graphAnalysis][pixel_dimensions]} \
        -pruning_scale {config[graphAnalysis][pruning_scale]} -length_limit {config[graphAnalysis][length_limit]} \
        -branching_threshold {config[graphAnalysis][branching_threshold]} \
        -all_stats {config[graphAnalysis][all_stats]} -experimental_flag {config[graphAnalysis][experimental_flag]}"
    if os == 'Linux' or os == 'Darwin':
        command_str = command_str + "\nchmod ugo+rwx \"{output}\""
    return command_str


def get_input(imgs, exts, blender_exists, path, input_list=[]):
    input_list.append(expand(path + "/{img}/{img}.{ext}_Statistics", zip, img=imgs, ext=exts))
    if config['3D'] == 1 and config['render'] == 1 and blender_exists:
        input_list.append(expand(path + "/{img}/Binary_{img}-render.PNG", img=imgs))
        input_list.append(expand(path + "/{img}/Binary_{img}.blend",img=imgs))
        input_list.append(expand(path + "/{img}/Binary_{img}.glb",img=imgs))
        input_list.append(expand(path + "/{img}/Skeleton_{img}-render.PNG",img=imgs))
        input_list.append(expand(path + "/{img}/Skeleton_{img}.blend",img=imgs))
        input_list.append(expand(path + "/{img}/Skeleton_{img}.glb",img=imgs))
    return input_list


configfile: os.path.join(snakemake.workflow.srcdir('scripts'), '../..', 'data/config.json')
PATH = os.path.abspath(os.path.join(snakemake.workflow.srcdir('scripts'), '../..', 'data'))
SCRIPT_PATH = snakemake.workflow.srcdir('scripts')
FRANGINET_PATH = os.path.join(snakemake.workflow.srcdir('scripts'), '../..', 'FrangiNet')
IMGS, EXTS = get_files_and_extensions(path=PATH)
OS = platform.system()
SIGMA_SMALL = str(config['frangi_small']['sigma_min'])
SIGMA_LARGE = str(config['frangi_large']['sigma_min'])

if OS == 'Linux':
    ENV_PATH = 'envs/Linux/'
    #BLENDER_PATH = '/usr/bin/blender'
    BLENDER_PATH = '/usr/bin/blender-2.83.4-linux64/blender'
else:
    ENV_PATH = 'envs/Mac/'
    BLENDER_PATH = '/Applications/Blender.app/Contents/MacOS/Blender'
if os.path.exists(BLENDER_PATH):
    BLENDER = True
else:
    BLENDER = False

# specify which of the rules for individual frangi should be applied
if config["3D"] == 1:
    if config["segmentation"] == "frangi":
        ruleorder: segmentation_frangi > segmentation_frangi2D > segmentation_franginet > segmentation_franginet_gpu
    elif config["segmentation"] == "franginet":
        ruleorder: segmentation_franginet > segmentation_frangi > segmentation_frangi2D > segmentation_franginet_gpu
    elif config["segmentation"] == "franginet_gpu":
        ruleorder: segmentation_franginet_gpu > segmentation_franginet > segmentation_frangi > segmentation_frangi2D
else:
    ruleorder: segmentation_frangi2D > segmentation_frangi > segmentation_franginet > segmentation_franginet_gpu

rule all:
    input: get_input(IMGS, EXTS, BLENDER, PATH)

rule makeImgDir:
    input: PATH + "/{img}.{ext}"
    output: PATH + "/{img}/{img}.{ext}"
    shell: "mv \"{input}\" \"{output}\""

# dual frangi: apply 2 frangi filters with specific sigma and combine the results
if config["segmentation"] == "dual_frangi":
    rule segmentation_frangi_small:
        input: PATH + "/{img}/{img}.{ext}"
        output: PATH + "/{img}/Frangi_{img}_" + SIGMA_SMALL + ".{ext}"
        wildcard_constraints:
            ext="(tiff)"
        conda: ENV_PATH + "vmtk.yml"
        # benchmark: PATH + "/{img}/benchmarks/{img}.frangi.benchmark.txt"
        shell: "python " + SCRIPT_PATH + "/frangi3D.py -i \"{input}\" -o {output} -sigma_min {config[frangi_small][sigma_min]} \
                -sigma_max {config[frangi_small][sigma_max]} -sigma_steps {config[frangi_small][sigma_steps]} \
                -alpha {config[frangi_small][alpha]} -beta {config[frangi_small][beta]} -gamma {config[frangi_small][gamma]}"

    rule segmentation_frangi_large:
        input: PATH + "/{img}/{img}.{ext}"
        output: PATH + "/{img}/Frangi_{img}_" + SIGMA_LARGE + ".{ext}"
        wildcard_constraints:
            ext="(tiff)"
        conda: ENV_PATH + "vmtk.yml"
        # benchmark: PATH + "/{img}/benchmarks/{img}.frangi.benchmark.txt"
        shell: "python " + SCRIPT_PATH + "/frangi3D.py -i \"{input}\" -o {output} -sigma_min {config[frangi_large][sigma_min]} \
                -sigma_max {config[frangi_large][sigma_max]} -sigma_steps {config[frangi_large][sigma_steps]} \
                -alpha {config[frangi_large][alpha]} -beta {config[frangi_large][beta]} -gamma {config[frangi_large][gamma]}"

    rule merge_segmentations:
        input: raw=PATH + "/{img}/{img}.{ext}",
            frangi_small=PATH + "/{img}/Frangi_{img}_" + SIGMA_SMALL + ".{ext}",
            frangi_large=PATH + "/{img}/Frangi_{img}_" + SIGMA_LARGE + ".{ext}"
        output: PATH + "/{img}/Binary_{img}.{ext}"
        wildcard_constraints:
            ext="tiff"
        conda: ENV_PATH + "Pipeline.yml"
        # benchmark: PATH + "/{img}/benchmarks/{img}.threshold.benchmark.txt"
        shell: "python " + SCRIPT_PATH + "/merge_seg.py -raw \"{input[0]}\" -frangi_small \"{input[1]}\" -frangi_large \"{input[2]}\" "
# individual frangi
else:
    rule segmentation_frangi2D:
        input: PATH + "/{img}/{img}.{ext}"
        output: PATH + "/{img}/Frangi_{img}.{ext}"
        conda: ENV_PATH + "Pipeline.yml"
        shell: "python " + SCRIPT_PATH + "/frangi2D.py -i \"{input}\" \
                -sigma_min {config[frangi][sigma_min]} -sigma_max {config[frangi][sigma_max]} \
                -sigma_steps {config[frangi][sigma_steps]} -alpha {config[frangi][alpha]} -beta {config[frangi][beta]} \
                -gamma {config[frangi][gamma]} -denoise {config[threshold][denoise]}"

    rule segmentation_frangi:
        input: PATH + "/{img}/{img}.{ext}"
        output: PATH + "/{img}/Frangi_{img}.{ext}"
        wildcard_constraints:
            ext="(tiff)"
        conda: ENV_PATH + "vmtk.yml"
        # benchmark: PATH + "/{img}/benchmarks/{img}.frangi.benchmark.txt"
        shell: "python " + SCRIPT_PATH + "/frangi3D.py -i \"{input}\" -o {output} -sigma_min {config[frangi][sigma_min]} \
                -sigma_max {config[frangi][sigma_max]} -sigma_steps {config[frangi][sigma_steps]} \
                -alpha {config[frangi][alpha]} -beta {config[frangi][beta]} -gamma {config[frangi][gamma]}"

    rule segmentation_franginet:
        input: PATH + "/{img}/{img}.{ext}"
        output: PATH + "/{img}/Frangi_{img}.{ext}"
        wildcard_constraints:
            ext="(tiff)"
        conda: "envs/Linux/frangi-cpu.yml"
        #benchmark: PATH + "/{img}/benchmarks/{img}.frangi.benchmark.txt"
        shell: "python " + SCRIPT_PATH + "/franginet.py -i {input} -o {output} -model " + FRANGINET_PATH + "{config[franginet][model]} \
                -mode {config[franginet][mode]} -normalization {config[franginet][normalization]} \
                -average {config[franginet][average]} -mode_img {config[franginet][mode_img]} \
                -gpus {config[franginet][gpus]} -batch_size {config[franginet][batch_size]}"

    rule segmentation_franginet_gpu:
        input: PATH + "/{img}/{img}.{ext}"
        output: PATH + "/{img}/Frangi_{img}.{ext}"
        wildcard_constraints:
            ext="(tiff)"
        conda: "envs/Linux/frangi-gpu.yml"
        #benchmark: PATH + "/{img}/benchmarks/{img}.frangi.benchmark.txt"
        shell: "python " + SCRIPT_PATH + "/franginet.py -i {input} -o {output} -model" + FRANGINET_PATH + "{config[franginet][model]} \
                -mode {config[franginet][mode]} -normalization {config[franginet][normalization]} \
                -average {config[franginet][average]} -mode_img {config[franginet][mode_img]} \
                -gpus {config[franginet][gpus]} -batch_size {config[franginet][batch_size]}"

    rule thresholding:
        input: PATH + "/{img}/Frangi_{img}.{ext}"
        output: PATH + "/{img}/Binary_{img}.{ext}"
        wildcard_constraints:
            ext="(tiff|png|jpg)"
        conda: ENV_PATH + "Thresholding.yml"
        # benchmark: PATH + "/{img}/benchmarks/{img}.threshold.benchmark.txt"
        shell: "python " + SCRIPT_PATH + "/thresholding.py -i \"{input}\" -value {config[threshold][value]} \
                -pixel_dimensions {config[graphAnalysis][pixel_dimensions]} \
                -ball_radius {config[threshold][ball_radius]} -artifact_size {config[threshold][artifact_size]} \
                -block_size {config[threshold][block_size]}"

rule renderBinary:
    input: PATH + "/{img}/Binary_{img}.stl"
    output: PATH + "/{img}/Binary_{img}-render.PNG", PATH + "/{img}/Binary_{img}.glb", PATH + "/{img}/Binary_{img}.blend"
    conda: ENV_PATH + "Pipeline.yml"
    shell:
            BLENDER_PATH + " --background --python " + SCRIPT_PATH + "/render_object.py -- -model_file_path \"{input}\" -out_dir \"{PATH}/{wildcards.img}/\" \
            -save_raw {config[rendering][save_raw]} -save_glb {config[rendering][save_glb]} -render_device {config[rendering][render_device]} \
            -render_distance {config[rendering][render_distance]} \
            -image_resolution_x {config[rendering][image_resolution_x]} \
            -image_resolution_y {config[rendering][image_resolution_y]} \
            -image_compression {config[rendering][image_compression]} \
            -mesh_r {config[rendering_binary][mesh_r]} -mesh_g {config[rendering_binary][mesh_g]} \
            -mesh_b {config[rendering_binary][mesh_b]} -mesh_roughness {config[rendering_binary][mesh_roughness]} \
            -mesh_metallic {config[rendering_binary][mesh_metallic]} \
            -mesh_sheen {config[rendering_binary][mesh_sheen]} -mesh_specular {config[rendering_binary][mesh_specular]}"

rule skeletonize_scikit:
    input: PATH + "/{img}/Binary_{img}.{ext}"
    output: PATH + "/{img}/Skeleton_{img}.{ext}"
    wildcard_constraints:
        ext="(tiff|png|jpg)"
    conda: ENV_PATH + "Pipeline.yml"
    #benchmark: PATH + "/{img}/benchmarks/{img}.skeletonize.benchmark.txt"
    shell: "python " + SCRIPT_PATH + "/skeletonize_scikit.py -i \"{input}\" -pixel_dimensions {config[graphAnalysis][pixel_dimensions]}"

rule renderSkeleton:
    input: PATH + "/{img}/Skeleton_{img}.stl"
    output: PATH + "/{img}/Skeleton_{img}-render.PNG", PATH + "/{img}/Skeleton_{img}.glb", PATH + "/{img}/Skeleton_{img}.blend"
    conda: ENV_PATH + "Pipeline.yml"
    shell:
            BLENDER_PATH + " --background --python " + SCRIPT_PATH + "/render_object.py -- -model_file_path \"{input}\" -out_dir \"{PATH}/{wildcards.img}/\" \
            -save_raw {config[rendering][save_raw]} -save_glb {config[rendering][save_glb]} -render_device {config[rendering][render_device]} \
            -render_distance {config[rendering][render_distance]} \
            -image_resolution_x {config[rendering][image_resolution_x]} \
            -image_resolution_y {config[rendering][image_resolution_y]} \
            -image_compression {config[rendering][image_compression]} \
            -mesh_r {config[rendering_skeleton][mesh_r]} -mesh_g {config[rendering_skeleton][mesh_g]} \
            -mesh_b {config[rendering_skeleton][mesh_b]} -mesh_roughness {config[rendering_skeleton][mesh_roughness]} \
            -mesh_metallic {config[rendering_skeleton][mesh_metallic]} \
            -mesh_sheen {config[rendering_skeleton][mesh_sheen]} -mesh_specular {config[rendering_skeleton][mesh_specular]}"

rule graphAnalysis:
    input: skelImg = PATH + "/{img}/Skeleton_{img}.{ext}", binImg = PATH + "/{img}/Binary_{img}.{ext}"
    output: directory(PATH + "/{img}/{img}.{ext}_Statistics/")
    conda: ENV_PATH + "Pipeline.yml"
    #benchmark: PATH + "/{img}/benchmarks/{img}.graphAnalysis.benchmark.txt"
    shell: get_graphAnalysis_command(OS, SCRIPT_PATH)

if config['3D'] == 1:
    rule createBinaryObj:
        input: PATH + "/{img}/Binary_{img}.tiff"
        output: PATH + "/{img}/Binary_{img}.stl"
        conda: ENV_PATH + "Pipeline.yml"
        shell: "python -W ignore " + SCRIPT_PATH + "/create_stl.py -i \"{input}\" -o \"{output}\" \
                -pixel_dimensions {config[graphAnalysis][pixel_dimensions]}"

    rule createSkeletonObj:
        input: PATH + "/{img}/Skeleton_{img}.tiff"
        output: PATH + "/{img}/Skeleton_{img}.stl"
        conda: ENV_PATH + "Pipeline.yml"
        shell: "python -W ignore " + SCRIPT_PATH + "/create_stl.py -i \"{input}\" -o \"{output}\" \
                -pixel_dimensions {config[graphAnalysis][pixel_dimensions]} -dilation True"